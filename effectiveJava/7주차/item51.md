## 아이템 51. 메서드 시그니처를 신중히 설계하라

1. 메서드 이름을 신중히 짓자

- **표준 명명 규칙**을 따른다. (아이템 68)

- 자바 라이브러리의 API를 참고하자.
- 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하자.

2. 편의 메서드를 너무 많이 만들지 말자

**편의 메서드란?**

편의 메서드(convenience method)란 말 그대로 편의를 위한 메서드입니다.

예를 들면, 헬퍼 클래스인 `Collections` 안에 있는 모든 메서드(`swap`, `min`, `max` 등등...)를 말합니다. JPA를 사용하신다면 1:N 관계 중 N쪽에 요소를 추가할 때 직접 만들어서 사용하는 `add()` 메서드도 편의 메서드입니다.

**왜 편의 메서드를 만들까요?**

편의 메서드가 없어도 기능 상 문제가 없어 그대로 사용할 수 있습니다. 그러나 편의 메서드를 사용하면 메서드에 이름을 줘서 좀 더 명확하게 무슨 일을 하는 지 말해줄 수 있으며 기능 단위로 묶을 수 있고 재사용할 수 있습니다.

**왜 편의 메서드를 많이 만들면 안될까요?**

- 메서드가 너무 많은 클래스는 문서화하고, 테스트하고 유지보수하고 사용하기 어렵습니다
- **클래스나 인터페이스는 자신의 기능을 수행하는 메서드를 제공해야 합니다**

자주 쓰일 경우에만 만들고 확신이 서지 않으면 만들지 않는 게 낫습니다

3. 매개변수 개수는 적게 유지하기

매개변수 갯수가 4개를 넘어가면 매개변수를 기억하기 쉽지 않다고 합니다. 4개 이하를 유지합시다.

만약 같은 타입의 매개변수가 여러 개라면 더 고민해봐야 합니다. 왜냐하면 실수로 순서를 바꿔 입력해도 그대로 컴파일되고 실행되기 때문입니다.

### 매개변수 개수를 줄여주는 기술 세 가지

**1 - 여러 메서드로 쪼개기**

매개변수가 너무 많다면 원래 매개변수의 부분 집합을 받아 메서드를 쪼갤 수 있습니다.

예를 들어, 어떤 리스트에서 주어진 원소를 찾아야 하는데 전체 리스트가 아니라 지정된 범위의 부분 리스트에서 주어진 원소를 찾아야 하는 요구사항이 들어왔다고 해볼게요. 이 기능을 하나의 메서드로 구현하려면 부분 리스트의 시작, 부분 리스트의 끝, 찾을 원소 까지 총 3개의 매개변수가 필요합니다.

```java
findElementAtSubList(int fromIndexOfSubList, int toIndexOfSubList, Object element);
```

여기서 여러 메서드로 쪼갠다면 아래와 같은 방식으로 쪼갤 수 있습니다.

```java
List<E> subList(int fromIndex, int toIndex);

int indexOf(Object o);
```

요구사항을 구현할 때는 `subList()`로 `List`를 구한 후, `indexOf()`로 원소를 찾으면 됩니다.

여기서 눈여겨볼 것은 단순히 매개변수의 개수가 많다고 해서 여러 메서드로 쪼개는 것이 아니라는 겁니다. 

주어진 요구사항을 다시 생각해볼게요. 지정된 범위의 부분 리스트에서 주어진 원소를 찾아야 하는 요구사항입니다. 이 요구사항에는 기능을 두 가지로 분리할 수 있습니다. **지정된 범위의 부분 리스트를 구하는 기능**과 **주어진 원소를 찾는 기능**입니다. 이 두 기능을 생각해보면 공통점이 없습니다.

공통점이 없는데 하나의 메서드로 쓰이는 게 맞을까요? 아니죠. 분리되어야 합니다 이렇게 분리해서 기능으로 만든다면 다른 곳에서도 쉽게 조합해서 사용할 수 있습니다.

'공통점이 없는 기능이 잘 분리되었다'를 전문적인 말로 '직교성이 높다'라고 합니다. (저도 처음들었습니다ㅎㅎ) 아키텍처에도 직교성을 대입해본다면 마이크로 서비스 아키텍처는 직교성이 높고, 모놀리식 아키텍처는 직교성이 낮다고 할 수 있습니다.

**기능을 쪼개다보면 자연스럽게 중복이 줄고 결합성이 낮아집니다. 코드를 수정하고 테스트하기 쉬워지는 거죠. 그렇다고 무한정 작게 나누는 게 좋은 건 아닙니다. API 사용자의 눈높이에 맞게, API가 다루는 개념의 추상화 수준에 맞게 조절해야 합니다.**

기능을 잘 쪼갠(직교성이 높게 개발한) 예시가 List 인터페이스입니다. List 인터페이스를 보면 말 그대로 `subList()`는 부분 리스트를 반환하고 `indexOf()` 메서드는 주어진 원소의 인덱스를 알려줍니다. 별개로 제공된 두 메서드를 조합하면 우리가 원하던 지정된 범위의 부분 리스트에서 인덱스를 찾는 기능을 완성시킬 수 있는 거죠.

**2 - 매개변수 여러 개를 묶는 도우미 클래스를 만들기**

매개변수가 많다면 매개변수를 묶어줄 수 있는 클래스를 만들어서 하나의 객체로 전달할 수 있습니다.

예를 들어, 카드 게임인 블랙잭을 구현한다고 해볼게요. 카드 게임에서 각 게임자에게 카드를 나누는 행위(dealing)를 구현한다면 게임자에게 카드를 나눠야 하니 게임자의 이름과 카드가 필요합니다. rank는 카드의 숫자이며 suit은 카드의 무늬입니다.

```java
dealing(String gamerName, String rank, String suit)
```

rank(카드의 숫자), suit(카드의 무늬)는 항상 같이 다니게 됩니다. 도메인을 생각했을 때 게임자에게 카드를 주지 카드의 숫자를 따로 주진 않으니까요.

```java
dealing(String gamerName, Card card)
```

```java
class Blackjack {
    // 도우미 클래스 (정적 멤버 클래스)
    static class Card {
        private String rank;
        private String suit;
    }

    public void dealing(gamerName, card);
}
```

이처럼 rank와 suit을 묶는 도우미 클래스(정적 멤버 클래스)를 만들면 하나의 매개변수로 주고 받을 수 있습니다.

예시에 개인적인 견해를 추가하자면 Card는 다른 곳에서도 쓰이고 카드 자체의 역할(rank와 suit의 우선순위 등)이 있기 때문에 매개변수를 위한 도우미 클래스가 아니라 클래스를 따로 만드는 게 맞다고 생각합니다. rank나 suit도 확장과 유연함을 고려해(10을 넘으면 J, Q, K로 표현되는 등) `String`보다 `Enum`으로 만든다면 더 나은 설계가 될 것 같네요 :)

**3 - 빌더 패턴을 적용한 객체를 메서드 호출에 응용하기**

도우미 클래스에 빌더 패턴을 적용한 것이라고 생각하시면 됩니다.

먼저 모든 매개변수를 하나로 추상화한 객체를 정의합니다. 그리고 그 객체에 빌더 패턴을 적용합니다. 클라이언트에서 해당 객체의 setter를 호출해 필요한 값을 설정합니다. 마지막으로 `validate()`를 통해 필드 유효성 검사를 합니다. 객체를 넘겨 계산을 수행합니다. 매개 변수가 많으면서 그 중 일부는 생략해도 좋을 때 도움이 됩니다.

### 매개변수의 타입으로는 클래스보다 인터페이스가 더 낫다

매개변수 타입으로 인터페이스를 사용하면 훨씬 더 나은 유연함을 제공합니다. 예를 들어, `HashMap이` 아니라 인터페이스인 Map을 사용하면 `TreeMap`, `ConcurrentHashMap`, `TreeMap` 등 어떤 `Map` 구현체라도 인수로 건넬 수 있습니다.

만약 HashMap 클래스를 매개변수 타입으로 사용한다면 클라이언트에게 특정 구현체만 사용하도록 제한하는 꼴이 됩니다. 혹여나 입력 형태가 HashMap이 아닌 다른 형태로 존재한다면 HashMap으로 옮겨 담아야 하니 그만큼의 복사 비용을 치뤄야 합니다.